import 'dart:developer';

import 'package:e_comerece/core/class/statusrequest.dart';
import 'package:e_comerece/core/constant/routesname.dart';
import 'package:e_comerece/core/funcations/handle_paging_response.dart';
import 'package:e_comerece/core/funcations/handlingdata.dart';
import 'package:e_comerece/core/funcations/translate_data.dart';
import 'package:e_comerece/data/datasource/remote/amazon_data/categories_amazon_data.dart';
import 'package:e_comerece/data/datasource/remote/amazon_data/hot_deals_amazon_data.dart';
import 'package:e_comerece/data/datasource/remote/amazon_data/search_amazon_data.dart';
import 'package:e_comerece/data/datasource/remote/api_cash/get_cash_data.dart';
import 'package:e_comerece/data/datasource/remote/api_cash/insert_cash_data.dart';
import 'package:e_comerece/data/model/amazon_models/categories_amazon_model.dart';
import 'package:e_comerece/data/model/amazon_models/hotdeals_amazon_model.dart';
import 'package:e_comerece/data/model/amazon_models/search_amazon_model.dart'
    as search;
import 'package:flutter/material.dart';
import 'package:get/get.dart';

abstract class AmazonHomeController extends GetxController {
  Future<void> fetchHomePageData();
  Future<void> searshText();
  // Future<void> fetchOnrefresh();
  Future<void> fetchCategories();
  Future<void> fetchProducts({required bool isLoadMore});
  Future<void> otherProducts({bool isLoadMore = false});
  // void loadMore();
  void loadMoreSearch();
  void onTapSearch();
  void onChangeSearch(String value);
  void goTofavorite();
  loadMoreOtherProduct();
  void gotoditels({
    required String asin,
    required String lang,
    required String title,
  });
  // void goToSearchByimage();
  // void gotoshearchname(String nameCat, int categoryId);
  void indexchange(int index);
}

class AmazonHomeControllerImpl extends AmazonHomeController {
  CategoriesAmazonData categoryData = CategoriesAmazonData(Get.find());
  HotDealsAmazonData hotDealsData = HotDealsAmazonData(Get.find());
  SearchAmazonData searchData = SearchAmazonData(Get.find());
  InsertCashData insertCashData = InsertCashData(Get.find());
  GetCashData getCashData = GetCashData(Get.find());

  Statusrequest statusrequestHome = Statusrequest.none;
  Statusrequest statusrequestcat = Statusrequest.none;
  Statusrequest statusrequestsearch = Statusrequest.none;
  Statusrequest statusrequestHotProducts = Statusrequest.none;
  Statusrequest statusrequestOtherProduct = Statusrequest.none;

  TextEditingController searchController = TextEditingController();
  TextEditingController startPriceController = TextEditingController(text: '1');
  TextEditingController endPriceController = TextEditingController(text: '500');
  FocusNode searchFocusNode = FocusNode();
  FocusNode startPriceFocusNode = FocusNode();
  FocusNode endPriceFocusNode = FocusNode();

  List<Datum> categories = [];
  List<Deal> hotDeals = [];
  List<search.Product> searchProducts = [];
  List<search.Product> otherProduct = [];

  int offset = 0;
  int pageIndexSearch = 0;
  int pageIndexOtherProduct = 0;

  bool isLoading = false;
  bool hasMore = true;

  bool firstShowOther = true;

  bool isSearch = false;
  bool showClose = false;

  int currentIndex = 0;

  @override
  void onInit() {
    super.onInit();
    fetchHomePageData();
  }

  @override
  fetchCategories() async {
    statusrequestcat = Statusrequest.loading;
    final cacheResponse = await getCashData.getCash(
      query: 'categories:amazon:${enOrAr() == "ar_MA" ? "SA" : "AE"}',
      platform: "amazon",
    );
    final statuCash = handlingData(cacheResponse);
    if (statuCash == Statusrequest.success &&
        cacheResponse["status"] == "success") {
      if (cacheResponse["status"] == "success") {
        log("get from amazon categories cash =====================");
        final categoryResponse = cacheResponse["data"];
        statusrequestcat = handlingData(categoryResponse);
        if (statusrequestcat == Statusrequest.success) {
          if (categoryResponse is Map<String, dynamic> &&
              categoryResponse['status'] == 'OK') {
            CategoriesAmazonModel autogenerated =
                CategoriesAmazonModel.fromJson(categoryResponse);
            if (autogenerated.data.isNotEmpty) {
              categories.assignAll(autogenerated.data);
            }
          }
        }
      }
    } else {
      log("get categories amazon from api =====================");
      final categoryResponse = await categoryData.getCategories();
      statusrequestcat = handlingData(categoryResponse);
      if (statusrequestcat == Statusrequest.success) {
        if (categoryResponse is Map<String, dynamic> &&
            categoryResponse['status'] == 'OK') {
          CategoriesAmazonModel autogenerated = CategoriesAmazonModel.fromJson(
            categoryResponse,
          );
          if (autogenerated.data.isNotEmpty) {
            categories.assignAll(autogenerated.data);
            insertCashData.insertCash(
              query: 'categories:amazon:${enOrAr() == "ar_MA" ? "SA" : "AE"}',
              platform: "amazon",
              data: categoryResponse,
              ttlHours: "24",
            );
          }
        }
      }
    }
  }

  @override
  fetchProducts({isLoadMore = false}) async {
    cashkey(String q, int p) =>
        'homeproduct:amazon:${enOrAr() == "ar_MA" ? "SA" : "AE"}:$q:page=$p';
    if (isLoadMore) {
      if (isLoading || !hasMore) return;
      isLoading = true;
    } else {
      statusrequestHotProducts = Statusrequest.loading;
      offset = 1;
      hotDeals.clear();
      hasMore = true;
    }
    update();
    try {
      final cashe = await getCashData.getCash(
        query: cashkey("", offset),
        platform: "amazon",
      );
      if (cashe["status"] == "success") {
        log("get from amazon home cash =====================");
        final hotProductsResponse = cashe["data"];
        final status = handlingData(hotProductsResponse);
        if (status == Statusrequest.success) {
          if (hotProductsResponse is Map<String, dynamic> &&
              hotProductsResponse['status'] == 'OK') {
            var hotProductModel = HotDealsAmazonModel.fromJson(
              hotProductsResponse,
            );

            if (hotProductModel.data!.deals.isEmpty) {
              hasMore = false;
            } else {
              hotDeals.addAll(hotProductModel.data!.deals);
            }
            if (!isLoadMore) statusrequestHotProducts = Statusrequest.success;
          }
        } else {
          if (!isLoadMore) {
            statusrequestHotProducts =
                status as Statusrequest? ?? Statusrequest.failuer;
          }
          hasMore = false;
        }
      } else {
        log("get products amazon home from api =====================");
        final hotProductsResponse = await hotDealsData.getHotDeals(offset);

        final status = handlingData(hotProductsResponse);
        if (status == Statusrequest.success) {
          if (hotProductsResponse is Map<String, dynamic> &&
              hotProductsResponse['status'] == 'OK') {
            var hotProductModel = HotDealsAmazonModel.fromJson(
              hotProductsResponse,
            );

            if (hotProductModel.data!.deals.isEmpty) {
              hasMore = false;
            } else {
              hotDeals.addAll(hotProductModel.data!.deals);
              insertCashData.insertCash(
                query: cashkey("", offset),
                platform: "amazon",
                data: hotProductsResponse,
                ttlHours: "24",
              );
            }
            if (!isLoadMore) statusrequestHotProducts = Statusrequest.success;
          } else if (hotProductsResponse['data']['deals'].isEmpty) {
            hasMore = false;
            statusrequestHotProducts = Statusrequest.noDataPageindex;
            custSnackBarNoMore();
          }
        } else {
          if (!isLoadMore) {
            statusrequestHotProducts =
                status as Statusrequest? ?? Statusrequest.failuer;
          }
          hasMore = false;
        }
      }
    } catch (e) {
      log("error fetch products amazon home $e");
    }

    isLoading = false;
    update();
  }

  @override
  fetchHomePageData({bool isrefresh = false}) async {
    statusrequestHome = Statusrequest.loading;
    update();
    try {
      if (isrefresh == false) {
        await Future.wait([fetchCategories(), fetchProducts()]);
      } else {
        await Future.wait([fetchProducts()]);
      }
      if (statusrequestHome == Statusrequest.loading) {
        statusrequestHome = Statusrequest.success;
      }
    } catch (e, s) {
      // سجّل الاستثناء مع الـ stack trace عشان تعرف مكانه بالضبط
      log("error fetch home page amazon: $e\n$s");
      statusrequestHome = Statusrequest.failuer;
    }
    update();
  }

  @override
  gotoditels({required asin, required lang, required title}) {
    Get.toNamed(
      AppRoutesname.productDetailsAmazonView,
      arguments: {"asin": asin, "lang": lang, "title": title},
    );
  }

  @override
  searshText({bool isLoadMore = false, bool other = false}) async {
    cashkey(String q, int p) => 'search:amazon:$q:page=$p';

    if (isLoadMore) {
      if (isLoading || !hasMore) return;
      isLoading = true;
    } else {
      statusrequestsearch = Statusrequest.loading;
      pageIndexSearch = 1;
      searchProducts.clear();
      hasMore = true;
    }
    update();

    try {
      final int intStartPrice = int.tryParse(startPriceController.text) ?? 0;
      final int intEndPrice = int.tryParse(endPriceController.text) ?? 0;
      final cashe = await getCashData.getCash(
        query: cashkey(
          "${searchController.text}_${intStartPrice}_$intEndPrice",
          pageIndexSearch,
        ),
        platform: "amazon",
      );
      if (cashe["status"] == "success") {
        log("get from amazon search cash =====================");
        final response = cashe["data"];

        statusrequestsearch = handlingData(response);
        if (statusrequestsearch == Statusrequest.success) {
          if (response is Map<String, dynamic> && response['status'] == 'OK') {
            final model = search.SearchAmazonModel.fromJson(response);
            final List<search.Product> iterable = model.data!.products;

            if (iterable.isEmpty) {
              hasMore = false;
              statusrequestsearch = Statusrequest.noData;
            } else {
              searchProducts.addAll(iterable);
              pageIndexSearch++;
            }
          } else {
            hasMore = false;
            statusrequestsearch = Statusrequest.noData;
          }
        }
      } else {
        final response = await searchData.getSearch(
          startPrice: intStartPrice,
          endPrice: intEndPrice,
          lang: detectLangFromQueryAmazon(searchController.text),
          q: searchController.text,
          pageindex: pageIndexSearch,
        );

        statusrequestsearch = handlingData(response);
        if (statusrequestsearch == Statusrequest.success) {
          if (response is Map<String, dynamic> && response['status'] == 'OK') {
            final model = search.SearchAmazonModel.fromJson(response);
            final List<search.Product> iterable = model.data!.products;

            if (iterable.isEmpty && pageIndexSearch > 1) {
              hasMore = false;
              statusrequestsearch = Statusrequest.noDataPageindex;
              custSnackBarNoMore();
            } else if (iterable.isEmpty) {
              hasMore = false;
              statusrequestsearch = Statusrequest.noData;
            } else {
              searchProducts.addAll(iterable);
              insertCashData.insertCash(
                query: cashkey(
                  "${searchController.text}_${intStartPrice}_$intEndPrice",
                  pageIndexSearch,
                ),
                platform: "amazon",
                data: response,
                ttlHours: "24",
              );
              pageIndexSearch++;
            }
          } else {
            hasMore = false;
            statusrequestsearch = Statusrequest.noData;
          }
        }
      }
    } catch (e) {
      hasMore = false;
      statusrequestsearch = Statusrequest.failuer;
    } finally {
      if (isLoadMore) isLoading = false;
      update();
    }
  }

  @override
  loadMoreSearch() {
    searshText(isLoadMore: true);
  }

  @override
  onChangeSearch(String val) {
    if (val == "") {
      isSearch = false;
      update();
    }
  }

  whenstartSearch(String q) async {
    if (q != "") {
      showClose = true;
      update();
    } else {
      showClose = false;
    }
  }

  @override
  onTapSearch() {
    isSearch = true;
    searshText();
    update();
  }

  onCloseSearch() {
    if (isSearch) {
      isSearch = false;
      searchController.clear();
      update();
      showClose = false;
      // update(['initShow']);
    } else {
      searchController.clear();
      showClose = false;
      // update(['initShow']);
    }
  }

  @override
  goTofavorite() {
    Get.toNamed(
      AppRoutesname.favoritealiexpress,
      arguments: {'platform': "Amazon"},
    );
  }

  @override
  indexchange(int index) {
    currentIndex = index;
    update(["index"]);
  }

  @override
  otherProducts({bool isLoadMore = false}) async {
    cashkey(String q, int p) =>
        'otherproduct:amazon:${enOrAr() == "ar_MA" ? "SA" : "AE"}:$q:page=$p';
    final String query = "fashion";

    if (isLoadMore) {
      if (isLoading || !hasMore) return;
      isLoading = true;
    } else {
      statusrequestOtherProduct = Statusrequest.loading;
      pageIndexOtherProduct = 1;
      otherProduct.clear();
      hasMore = true;
    }
    update();

    try {
      final cashe = await getCashData.getCash(
        query: cashkey(query, pageIndexOtherProduct),
        platform: "amazon",
      );
      if (cashe["status"] == "success") {
        log("get from amazon other product cash =====================");
        final response = cashe["data"];

        statusrequestOtherProduct = handlingData(response);
        if (statusrequestOtherProduct == Statusrequest.success) {
          if (response is Map<String, dynamic> && response['status'] == 'OK') {
            final model = search.SearchAmazonModel.fromJson(response);
            final List<search.Product> iterable = model.data!.products;

            if (iterable.isEmpty) {
              hasMore = false;
              statusrequestOtherProduct = Statusrequest.noData;
            } else {
              otherProduct.addAll(iterable);
              pageIndexOtherProduct++;
            }
          } else {
            hasMore = false;
            statusrequestOtherProduct = Statusrequest.noData;
          }
        }
      } else {
        final response = await searchData.getSearch(
          startPrice: 1,
          endPrice: 1000,
          lang: enOrArAmazon(),
          q: query,
          pageindex: pageIndexOtherProduct,
        );

        statusrequestOtherProduct = handlingData(response);
        if (statusrequestOtherProduct == Statusrequest.success) {
          if (response is Map<String, dynamic> && response['status'] == 'OK') {
            final model = search.SearchAmazonModel.fromJson(response);
            final List<search.Product> iterable = model.data!.products;

            if (iterable.isEmpty && pageIndexOtherProduct > 1) {
              hasMore = false;
              statusrequestOtherProduct = Statusrequest.noDataPageindex;
              custSnackBarNoMore();
            } else if (iterable.isEmpty) {
              hasMore = false;
              statusrequestOtherProduct = Statusrequest.noData;
            } else {
              otherProduct.addAll(iterable);
              insertCashData.insertCash(
                query: cashkey(query, pageIndexOtherProduct),
                platform: "amazon",
                data: response,
                ttlHours: "24",
              );
              pageIndexOtherProduct++;
            }
          } else {
            hasMore = false;
            statusrequestOtherProduct = Statusrequest.noData;
          }
        }
      }
    } catch (e) {
      hasMore = false;
      statusrequestOtherProduct = Statusrequest.failuer;
    } finally {
      if (isLoadMore) isLoading = false;
      update();
    }
  }

  @override
  loadMoreOtherProduct() {
    otherProducts(isLoadMore: true);
  }

  goTOProductFromCategory(String categoryid) {
    Get.toNamed(
      AppRoutesname.productFromCatView,
      arguments: {'categories': categories, 'categoryId': categoryid},
    );
  }
}
